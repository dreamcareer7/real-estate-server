/**
 * @namespace Address
 */

const validator = require('../utils/validator.js')
const db = require('../utils/db.js')
const request = require('request')
const config = require('../config.js')
const qs = require('querystring')
const expect = validator.expect
const redis = require('redis').createClient(config.redis)

Address = {}

Orm.register('address', 'Address')

/**
 * PostgreSQL/PostGIS extension: **Geometry**(`Point`, `4326`)
 * @typedef point
 * @type {object}
 * @memberof Address
 * @instance
 */

/**
 * Geo-location service source
 * * `OSM`
 * * `Google`
 * * `Yahoo`
 * * `Bing`
 * * `Geonames`
 * * `Unknown`
 * * `None`
 * @typedef geo_source
 * @enum {string}
 * @memberof Address
 * @instance
 */

/**
 * GoogleMaps confidence and accuracy level for this address
 * * `APPROXIMATE`
 * * `RANGE_INTERPOLATED`
 * * `GEOMETRIC_CENTER`
 * * `ROOFTOP`
 * @typedef geo_confidence_google
 * @enum {string}
 * @memberof Address
 * @instance
 */

/**
 * Microsoft Bing confidence and accuracy level for this address
 * * `High`
 * * `Medium`
 * * `Low`
 * @typedef geo_confidence_bing
 * @enum {string}
 * @memberof Address
 * @instance
 */

/**
 * @typedef address
 * @type {object}
 * @memberof Address
 * @instance
 * @property {uuid} id - ID of this `address`
 * @property {string=} title - title
 * @property {string=} subtitle - subtitle
 * @property {string=} street_number - street number
 * @property {string=} street_name - street name
 * @property {string} city - city
 * @property {string} state - state
 * @property {string} state_code - state code
 * @property {string=} postal_code - postal code
 * @property {string=} neighborhood - neighborhood
 * @property {string=} street_suffix - street suffix
 * @property {string=} street_dir_suffix - street direction suffix
 * @property {string=} street_dir_prefix - street direction prefix
 * @property {string=} unit_number - unit number
 * @property {string} country - full country name
 * @property {string} country_code - 3 letter country code
 * @property {string=} direction - direction
 * @property {string=} street_number_searchable - searchable street number
 * @property {string=} county_or_parish - county or parish related to this address
 * @property {string=} geo_source_formatted_address_google - full formated address response generated by GoogleMaps API for this address
 * @property {string=} geo_source_formatted_address_bing - full formatted address response generated by Microsoft Bing API for this address
 * @property {Address#point=} location_google - GoogleMaps designated location for this address
 * @property {Address#point=} location_bing - Microsoft Bing designated location for this address
 * @property {Address#point=} location - our chosen location for this address
 * @property {Address#geo_source} geo_source - our chosen geo-location service source for this address
 * @property {Address#geo_confidence_google=} geo_confidence_google - GoogleMaps confidence and accuracy level for this address
 * @property {Address#geo_confidence_bing=} geo_confidence_bing - Microsoft Bing confidence and accuracy level for this address
 * @property {boolean=} geocoded_google - indicates whether this address is geocoded by GoogleMaps
 * @property {boolean=} geocoded_bing - indicates whether this address is geocoded by Bing
 * @property {boolean=} geocoded - indicates whether we have a decision on geocoding for this address
 * @property {boolean=} corrupted_google - indicates whether GoogleMaps was able to come up with an answer for this address
 * @property {boolean=} corrupted_bing - indicates whether Microsoft Bing was able to come up with an answer for this address
 * @property {boolean=} corrupted - indicates whether this address is corrupted based on our internal logic
 * @property {boolean=} approximate - A map for these addresses show not showup on client applications, since this is an estimated location
 * @property {boolean=} partial_match_google - partial match property indicator from GoogleMaps responses
 * @property {timestamp} created_at - indicates when this object was created
 * @property {timestamp=} updated_at - indicates when this object was last modified
 * @property {timestamp=} deleted_at - indicates when this object was deleted
 */

const schema = {
  type: 'object',
  properties: {
    title: {
      type: 'string',
      required: true
    },

    subtitle: {
      type: 'string',
      required: true
    }
  }
}

const validate = validator.bind(null, schema)

/**
 * Retrieves an `Address` object from database
 * @name get
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {uuid} address_id - ID of the referenced address
 * @param {callback} cb - callback function
 * @returns {Address#address} full address object
 */
Address.get = function (address_id, cb) {
  Address.getAll([address_id], (err, addresses) => {
    if(err)
      return cb(err)

    if(addresses.length < 1)
      return cb(Error.ResourceNotFound(`Address ${address_id} not found`))

    const address = addresses[0]

    return cb(null, address)
  })
}

Address.getAll = function(address_ids, cb) {
  expect(address_ids).to.be.a('array')

  db.query('address/get', [address_ids], (err, res) => {
    if (err)
      return cb(err)

    const addresses = res.rows.map(r => {
      if (r.location) {
        const location = JSON.parse(r.location)

        r.location = {
          longitude: location.coordinates[0],
          latitude: location.coordinates[1],
          type: 'location'
        }
      }

      return r
    })

    return cb(null, addresses)
  })
}

/**
 * Delete an address object from database
 * @name delete
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {uuid} address_id - ID of the referenced address
 * @param {callback} cb - callback function
 */
Address.delete = function (address_id, cb) {
  db.query('address/delete', [address_id], cb)
}

/**
 * Creates an address object
 * @name create
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {Address#address} address - full address object
 * @param {callback} cb - callback function
 * @returns {Address#address}
 */
Address.create = function (address, cb) {
  validate(address, function (err) {
    if (err)
      return cb(err)

    db.query('address/create', [
      address.title,
      address.subtitle,
      address.street_suffix,
      address.street_number,
      address.street_name,
      address.city,
      address.state,
      address.state_code,
      address.country,
      address.country_code,
      address.unit_number,
      address.postal_code,
      address.neighborhood,
      address.matrix_unique_id,
      address.county_or_parish,
      address.direction,
      address.street_dir_prefix,
      address.street_dir_suffix,
      address.street_number_searchable
    ], function (err, res) {
      if (err)
        return cb(err)

      return cb(null, res.rows[0].id)
    })
  })
}

/**
 * Converts an `Address` object to a searchable string compatible with GoogleMapsAPI and Bing services
 * @name getGeocodingSearchString
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {Address#address} address - full address object
 * @param {callback} cb - callback function
 * @returns {string} searchable address string
 */
Address.getGeocodingSearchString = function (address) {
  let standard = ''
  standard += (address.street_number) ? (' ' + address.street_number + ' ') : ''
  standard += (address.street_dir_prefix) ? (' ' + address.street_dir_prefix + ' ') : ''
  standard += (address.street_name) ? (' ' + address.street_name) : ''
  standard += (address.street_suffix) ? (' ' + address.street_suffix) : ''
  standard += (address.street_dir_suffix) ? (' ' + address.street_dir_suffix + ', ') : ', '
  standard += (address.city) ? (address.city + ', ') : ''
  standard += (address.state_code) ? (' ' + address.state_code + ' ') : ''
  standard += (address.postal_code) ? (' ' + address.postal_code + ' ') : ''
  standard = standard.trim()
  standard = standard.replace(/\s\s+/g, ' ')

  return standard
}

/**
 * Converts an `Address` object to a user friendly string which surfaces on the client app
 * @name getLocalized
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {Address#address} address - full address object
 * @param {callback} cb - callback function
 * @returns {string} user friendly address string
 */
Address.getLocalized = function (address) {
  let standard = ''
  standard += (address.street_number) ? (' ' + address.street_number + ' ') : ''
  standard += (address.street_dir_prefix) ? (' ' + address.street_dir_prefix + ' ') : ''
  standard += (address.street_name) ? (' ' + address.street_name) : ''
  standard += (address.street_suffix) ? (' ' + address.street_suffix) : ''
  standard += (address.street_dir_suffix) ? (' ' + address.street_dir_suffix) : ''
  standard += (address.unit_number) ? (', Unit ' + address.unit_number) : ''

  standard = standard.trim()
  standard = standard.replace(/\s\s+/g, ' ')

  return standard
}

/**
 * Maps an `Address` object based on Matrix_Unique_ID to a `Listing` object
 * @name mapToListing
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {uuid} address_id - ID of the referenced address
 * @param {callback} cb - callback function
 * @returns {listing} full listing object
 */
Address.mapToListing = function (address_id, cb) {
  Address.get(address_id, function (err, address) {
    if (err)
      return cb(err)

    db.query('address/map_to_listing', [address_id], function (err, res) {
      if (err)
        return cb(err)

      if (res.rows.length > 0)
        return cb(null, res.rows[0].id)

      return cb(null, null)
    })
  })
}

/**
 * Reschedules an address for generating `Recommendation` objects. This happens
 * when an address gets an updated geo-location information from one of our sources
 * @name reschedule
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {uuid} address_id - ID of the referenced address
 * @param {callback} cb - callback function
 * @returns {Recommendation#recommendation[]} full listing object
 */
Address.reschedule = function (address_id, cb) {
  Address.mapToListing(address_id, (err, listing_id) => {
    if(err)
      return cb(err)

    if (!listing_id)
      return cb(null, null)

    return Recommendation.generateForListing(listing_id, cb)
  })
}

/**
 * Updates geo-location information for an `Address` object from GoogleMaps API.
 * The following changes may happen on an `Address` object following this call:
 * * If the address in question gets a not found response from GoogleMaps, `corrupted_google` will be set to true
 * * If the address in question gets a partial match response from GoogleMaps, `partial_match` will be set to true
 * * GoogleMaps API formatted address field will be placed in `geo_source_formatted_address_google`
 * * `geo_confidence_google` will be set to the GoogleMaps API `location_type` field
 * * `approximate` field will be set to _true_ if the confidence is equal to `APPROXIMATE`, _false_ otherwise.
 * @name updateGeoFromGoogle
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {uuid} address_id - ID of the referenced address
 * @param {callback} cb - callback function
 * @returns {uuid} ID of the referenced address
 */
const cache_key = 'google_geocoded_addresses'

Address.updateGeoFromGoogle = function (address_id, cb) {
  let search_string

  const markAsCorrupt = (e) => {
    console.log('(Google) Geocoding failed:'.yellow, address_id, e)
    return Address.markAsCorruptedGoogle(address_id, cb)
  }

  const processResponse = (body) => {
    if (!body) {
      return markAsCorrupt('Response body is empty')
    }

    try {
      body = JSON.parse(body)
    } catch (e) {
      return markAsCorrupt('Unable to parse response body')
    }

    if (body.status !== 'OK') {
      return markAsCorrupt('Body status should be ok but it is', body.status)
    }

    redis.hset(cache_key, search_string, JSON.stringify(body))

    if (!body.results[0]) {
      return markAsCorrupt('No result found')
    }

    const location = {}
    let partial, confidence, formatted_address, approximate

    try {
      location.latitude = body.results[0].geometry.location.lat
      location.longitude = body.results[0].geometry.location.lng
      partial = body.results[0].partial_match
      confidence = body.results[0].geometry.location_type
      formatted_address = body.results[0].formatted_address
      approximate = (confidence === 'APPROXIMATE') ? true : false
    } catch (e) {
      return markAsCorrupt('Missing necessary information')
    }

    console.log('(Google) Geocode completed:'.green, 'confidence:', confidence)

    Address.updateLatLongGoogle(address_id, location, {
      formatted_address: formatted_address,
      source: 'Google',
      partial: partial,
      confidence: confidence,
      approximate: approximate
    }, function (err, address) {
      if (err)
        return cb(err)

      return cb(null, address.id)
    })
  }

  Address.get(address_id, function (err, address) {
    if (err)
      return cb(err)

    search_string = Address.getGeocodingSearchString(address)
    // eslint-disable-next-line handle-callback-err
    redis.hget(cache_key, search_string, (err, cached) => {
      if (cached) {
        Metric.increment('geocode.google.cache')
        return processResponse(cached)
      }

      request(config.google.url + (config.google.use_key ? ('?key=' + config.google.api_key + '&') : ('?')) + 'address=' + qs.escape(search_string), function (err, response, body) {
        Metric.increment('geocode.google')

        if (err)
          return cb(err)

        processResponse(body)
      })
    })
  })
}

/**
 * Updates geo-location information for an `Address` object from Bing API.
 * The following changes may happen on an `Address` object following this call:
 * * If the address in question gets a not found response from Bing API, `corrupted_bing` will be set to true
 * * Bing API formatted address field will be placed in `geo_source_formatted_address_bing`
 * * `geo_confidence_bing` will be set to the Bing API `confidence` field
 * * `approximate` field will be set to _false_ if confidence is `High`, _true_ otherwise.
 * @name updateGeoFromBing
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {uuid} address_id - ID of the referenced address
 * @param {callback} cb - callback function
 * @returns {uuid} ID of the referenced address
 */
Address.updateGeoFromBing = function (address_id, cb) {
  Metric.increment('geocode.bing')

  Address.get(address_id, function (err, address) {
    if (err)
      return cb(err)

    const standard = Address.getGeocodingSearchString(address)
    request(config.bing.url + '?q=' + qs.escape(standard) + '&key=' + config.bing.api_key, function (err, response, body) {
      if (err)
        return cb(err)

      if (body) {
        try {
          body = JSON.parse(body)
          if (body.statusCode === 200) {
            if (body.resourceSets[0]) {
              if (body.resourceSets[0].resources) {
                if (body.resourceSets[0].resources[0]) {
                  const location = {}
                  location.latitude = body.resourceSets[0].resources[0].point.coordinates[0]
                  location.longitude = body.resourceSets[0].resources[0].point.coordinates[1]
                  const partial = false // Not Available
                  const confidence = body.resourceSets[0].resources[0].confidence
                  const formatted_address = body.resourceSets[0].resources[0].address.formattedAddress
                  const approximate = (confidence === 'High') ? false : true

                  console.log('(Bing-Direct) NOTICE: UPDATING LAT/LONG for address with id:',
                              address_id, '(', standard, ') location:', location, 'confidence:', confidence)
                  Address.updateLatLongBing(address_id, location, {
                    formatted_address: formatted_address,
                    source: 'Bing',
                    partial: partial,
                    confidence: confidence,
                    approximate: approximate
                  }, function (err, address) {
                    if (err)
                      return cb(err)

                    return cb(null, address.id)
                  })
                } else {
                  console.log('(Bing-Direct) WARNING[6]: Error geocoding an address with id:', address_id)
                  return Address.markAsCorruptedBing(address_id, cb)
                }
              } else {
                console.log('(Bing-Direct) WARNING[5]: Error geocoding an address with id:', address_id)
                return Address.markAsCorruptedBing(address_id, cb)
              }
            } else {
              console.log('(Bing-Direct) WARNING[1]: Error geocoding an address with id:', address_id)
              return Address.markAsCorruptedBing(address_id, cb)
            }
          } else {
            console.log('(Bing-Direct) WARNING[2]: Error geocoding an address with id:', address_id)
            return Address.markAsCorruptedBing(address_id, cb)
          }
        }
        catch (e) {
          console.log('(Bing-Direct) WARNING[3]: Error geocoding an address with id:', address_id, 'with exception:', e)
          return Address.markAsCorruptedBing(address_id, cb)
        }
      } else {
        console.log('(Google-Direct) WARNING[4]: Error geocoding an address with id:', address_id)
        return Address.markAsCorruptedBing(address_id, cb)
      }
    })
  })
}

/**
 * Updates our chosen geo-location information based on the following policy:
 * * If GoogleMaps API has an entry with confidence level `ROOFTOP` then we use that otherwise
 * * If Bing has an entry with confidence level `High` then we use that otherwise
 * * If GoogleMaps has an entry with confidence level `RANGE_INTERPOLATED` then we use that otherwise
 * * If GoogleMaps has an entry with confidence level `GEOMETRIC_CENTER` then we use that, also setting `approximate field` otherwise
 * * If Bing has an entry that matches our postal code and street name then we use that and `approximate` is set otherwise
 * * If GoogleMaps has an entry that matches our postal code and street name then we use that and `approximate` is set otherwise
 * * If Bing has an entry that matches our postal code then we use that and `approximate` is set otherwise
 * * If Google has an entry that matches our postal code then we use that and `approximate` is set otherwise
 * * We use Bing and `approximate` is set
 * @name updateGeo
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {uuid} id - ID of the referenced address
 * @param {callback} cb - callback function
 * @returns {uuid} ID of the referenced address
 */
Address.updateGeo = function (id, cb) {
  Metric.increment('geocode')

  Address.updateGeoFromGoogle(id, function (err, address_id) {
    if (err)
      return cb(err)

    Address.updateGeoFromBing(id, function (err, address_id) {
      if (err)
        return cb(err)

      Address.get(id, (err, address) => {
        if(err)
          return cb(err)

        const gsfa_google = address.geo_source_formatted_address_google || ''
        const gsfa_bing = address.geo_source_formatted_address_bing || ''
        const gc_google = address.geo_confidence_google || ''
        const gc_bing = address.geo_confidence_bing || ''
        const g_bing = address.geocoded_bing

        if (gc_google === 'ROOFTOP') {
          return Address.updateLatLong(id, address.location_google, {source: 'Google', approximate: false}, cb)
        } else if (gc_bing === 'High') {
          return Address.updateLatLong(id, address.location_bing, {source: 'Bing', approximate: false}, cb)
        } else if (gc_google === 'RANGE_INTERPOLATED') {
          return Address.updateLatLong(id, address.location_google, {source: 'Google', approximate: false}, cb)
        } else if (gc_google === 'GEOMETRIC_CENTER') {
          return Address.updateLatLong(id, address.location_google, {source: 'Google', approximate: true}, cb)
        }

        if (gsfa_bing.indexOf(address.postal_code) !== -1 && gsfa_bing.indexOf(address.street_name) !== -1) {
          return Address.updateLatLong(id, address.location_bing, {source: 'Bing', approximate: true}, cb)
        } else if (gsfa_google.indexOf(address.postal_code) !== -1 && gsfa_google.indexOf(address.street_name) !== -1) {
          return Address.updateLatLong(id, address.location_google, {source: 'Google', approximate: true}, cb)
        } else if (gsfa_bing.indexOf(address.postal_code) !== -1) {
          return Address.updateLatLong(id, address.location_bing, {source: 'Bing', approximate: true}, cb)
        } else if (gsfa_google.indexOf(address.postal_code) !== -1) {
          return Address.updateLatLong(id, address.location_google, {source: 'Google', approximate: true}, cb)
        } else if (g_bing) {
          return Address.updateLatLong(id, address.location_bing, {source: 'Bing', approximate: true}, cb)
        }

        return Address.markAsCorrupted(id, cb)
      })
    })
  })
}

/**
 * Marks an `Address` object as corrupted
 * @name markAsCorrupted
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {uuid} address_id - ID of the referenced address
 * @param {callback} cb - callback function
 * @returns {boolean}
 */
Address.markAsCorrupted = function (address_id, cb) {
  db.query('address/mark_as_corrupted', [address_id], function (err, res) {
    if (err)
      return cb(err)

    return cb(null, false)
  })
}

/**
 * Marks an `Address` object as not convertible to geo-location by GoogleMaps API
 * @name markAsCorruptedGoogle
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {uuid} id - ID of the referenced address
 * @param {callback} cb - callback function
 * @returns {boolean}
 */
Address.markAsCorruptedGoogle = function (address_id, cb) {
  db.query('address/mark_as_corrupted_google', [address_id], function (err, res) {
    if (err)
      return cb(err)

    return cb(null, false)
  })
}

/**
 * Marks an `Address` object as not convertible to geo-location by Bing API
 * @name markAsCorruptedBing
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {uuid} id - ID of the referenced address
 * @param {callback} cb - callback function
 * @returns {boolean}
 */
Address.markAsCorruptedBing = function (id, cb) {
  db.query('address/mark_as_corrupted_bing', [id], function (err, res) {
    if (err)
      return cb(err)

    return cb(null, false)
  })
}

/**
 * Updates an `Address` object GoogleMaps API geo-location information
 * @name updateLatLongGoogle
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {uuid} address_id - ID of the referenced address
 * @param {callback} cb - callback function
 * @returns {Address#address} full address object
 */
Address.updateLatLongGoogle = function (address_id, location, aux, cb) {
  db.query('address/update_latlong_google', [
    location.longitude,
    location.latitude,
    aux.partial,
    aux.formatted_address,
    aux.confidence,
    address_id
  ], function (err, res) {
    if (err)
      return cb(err)

    Address.get(address_id, cb)
  })
}

/**
 * Updates an `Address` object Bing API geo-location information
 * @name updateLatLongBing
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {uuid} address_id - ID of the referenced address
 * @param {callback} cb - callback function
 * @returns {Address#address} full address object
 */
Address.updateLatLongBing = function (address_id, location, aux, cb) {
  db.query('address/update_latlong_bing', [
    location.longitude,
    location.latitude,
    aux.formatted_address,
    aux.confidence,
    address_id
  ], function (err, res) {
    if (err)
      return cb(err)

    Address.get(address_id, cb)
  })
}

/**
 * Updates an `Address` object geo-location information
 * @name updateLatLong
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {uuid} address_id - ID of the referenced address
 * @param {callback} cb - callback function
 * @returns {uuid} ID of the referenced address
 */
Address.updateLatLong = function (address_id, location, aux, cb) {
  db.query('address/update_latlong', [
    location,
    aux.source,
    aux.approximate,
    address_id
  ], function (err, res) {
    if (err)
      return cb(err)

    return cb(null, address_id)
  })
}

/**
 * Retrieves a batch of addresses from database that don't have geo-location
 * information updated from GoogleMaps API.
 * @name getBatchOfAddressesWithoutLatLongGoogle
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {number} limit - maximum number of results allowed to be retrieved
 * @param {callback} cb - callback function
 * @returns {uuid[]} ID of the addresses missing GoogleMaps API geo-location information
 */
Address.getBatchOfAddressesWithoutLatLongGoogle = function (limit, cb) {
  db.query('address/batch_latlong_google', [limit], function (err, res) {
    if (err)
      return cb(err)

    const address_ids = res.rows.map(function (r) {
      return r.id
    })

    return cb(null, address_ids)
  })
}

/**
 * Retrieves a batch of addresses from database that don't have geo-location
 * information updated from Bing API and have Google confidence level lower than `ROOFTOP`
 * @name getBatchOfAddressesWithoutLatLongBing
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {number} limit - maximum number of results allowed to be retrieved
 * @param {callback} cb - callback function
 * @returns {uuid[]} ID of the addresses missing Bing API geo-location information
 */
Address.getBatchOfAddressesWithoutLatLongBing = function (limit, cb) {
  db.query('address/batch_latlong_bing', [limit], function (err, res) {
    if (err)
      return cb(err)

    const address_ids = res.rows.map(function (r) {
      return r.id
    })

    return cb(null, address_ids)
  })
}

/**
 * Creates a PostgreSQL compatible string to represent a POLYGON object
 * @name getGeomTextFromLocationArray
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {Address#point[]}
 * @returns {string} PostgreSQL compatible string to represent a POLYGON object
 */
Address.getGeomTextFromLocationArray = function (array) {
  let points = array.map(function (r) {
    return (r.longitude + ' ' + r.latitude)
  })

  points = 'POLYGON((' + points.join(',') + '))'

  return points
}

Address.fixMissing = function(cb) {
  db.query('address/fix_missing', [], (err, res) => {
    if(err)
      return cb(err)

    const ids = res.rows.map(r => r.id)

    return cb(null, ids)
  })
}

module.exports = function () {}
